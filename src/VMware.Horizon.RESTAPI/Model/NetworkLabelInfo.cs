/* 
 * Horizon Server API
 *
 * Welcome to the Horizon Server API Reference documentation. This API reference provides comprehensive information about status of all Horizon Server components and resources.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = VMware.Horizon.RESTAPI.Client.SwaggerDateConverter;

namespace VMware.Horizon.RESTAPI.Model
{
    /// <summary>
    /// Information related to network label.
    /// </summary>
    [DataContract]
    public partial class NetworkLabelInfo :  IEquatable<NetworkLabelInfo>, IValidatableObject
    {
        /// <summary>
        /// Defines IncompatibleReasons
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum IncompatibleReasonsEnum
        {
            
            /// <summary>
            /// Enum NOTCONFIGUREDONALLHOSTS for value: NOT_CONFIGURED_ON_ALL_HOSTS
            /// </summary>
            [EnumMember(Value = "NOT_CONFIGURED_ON_ALL_HOSTS")]
            NOTCONFIGUREDONALLHOSTS = 1,
            
            /// <summary>
            /// Enum DVSUPLINKPORT for value: DVS_UPLINK_PORT
            /// </summary>
            [EnumMember(Value = "DVS_UPLINK_PORT")]
            DVSUPLINKPORT = 2,
            
            /// <summary>
            /// Enum VMCNETWORKS for value: VMC_NETWORKS
            /// </summary>
            [EnumMember(Value = "VMC_NETWORKS")]
            VMCNETWORKS = 3
        }


        /// <summary>
        /// Reasons that may preclude this Network Label from being used in desktoppool/farm configuration.
        /// </summary>
        /// <value>Reasons that may preclude this Network Label from being used in desktoppool/farm configuration.</value>
        [DataMember(Name="incompatible_reasons", EmitDefaultValue=false)]
        public List<IncompatibleReasonsEnum> IncompatibleReasons { get; set; }
        /// <summary>
        /// Network label type. * EARLY_BINDING: A free Distributed Virtual Port will be selected and assigned to a Virtual Machine when the Virtual Machine is reconfigured to connect to the portgroup. Instant clones desktop pools/farms only support port group type of early binding. * EPHEMERAL: A Distributed Virtual Port will be created and assigned to a Virtual Machine when the Virtual Machine is powered on, and will be deleted when the Virtual Machine is powered off. An ephemeral portgroup has no limit on the number of ports that can be a part of this portgroup. In cases where the vCenter Server is unavailable the host can create conflict ports in this portgroup to be used by a Virtual Machine at power on. * LATE_BINDING: Deprecated as of vSphere API 5.0 A free DistributedVirtualPort will be selected and assigned to a Virtual Machine when the Virtual Machine is powered on.
        /// </summary>
        /// <value>Network label type. * EARLY_BINDING: A free Distributed Virtual Port will be selected and assigned to a Virtual Machine when the Virtual Machine is reconfigured to connect to the portgroup. Instant clones desktop pools/farms only support port group type of early binding. * EPHEMERAL: A Distributed Virtual Port will be created and assigned to a Virtual Machine when the Virtual Machine is powered on, and will be deleted when the Virtual Machine is powered off. An ephemeral portgroup has no limit on the number of ports that can be a part of this portgroup. In cases where the vCenter Server is unavailable the host can create conflict ports in this portgroup to be used by a Virtual Machine at power on. * LATE_BINDING: Deprecated as of vSphere API 5.0 A free DistributedVirtualPort will be selected and assigned to a Virtual Machine when the Virtual Machine is powered on.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum LabelTypeEnum
        {
            
            /// <summary>
            /// Enum EARLYBINDING for value: EARLY_BINDING
            /// </summary>
            [EnumMember(Value = "EARLY_BINDING")]
            EARLYBINDING = 1,
            
            /// <summary>
            /// Enum EPHEMERAL for value: EPHEMERAL
            /// </summary>
            [EnumMember(Value = "EPHEMERAL")]
            EPHEMERAL = 2,
            
            /// <summary>
            /// Enum LATEBINDING for value: LATE_BINDING
            /// </summary>
            [EnumMember(Value = "LATE_BINDING")]
            LATEBINDING = 3
        }

        /// <summary>
        /// Network label type. * EARLY_BINDING: A free Distributed Virtual Port will be selected and assigned to a Virtual Machine when the Virtual Machine is reconfigured to connect to the portgroup. Instant clones desktop pools/farms only support port group type of early binding. * EPHEMERAL: A Distributed Virtual Port will be created and assigned to a Virtual Machine when the Virtual Machine is powered on, and will be deleted when the Virtual Machine is powered off. An ephemeral portgroup has no limit on the number of ports that can be a part of this portgroup. In cases where the vCenter Server is unavailable the host can create conflict ports in this portgroup to be used by a Virtual Machine at power on. * LATE_BINDING: Deprecated as of vSphere API 5.0 A free DistributedVirtualPort will be selected and assigned to a Virtual Machine when the Virtual Machine is powered on.
        /// </summary>
        /// <value>Network label type. * EARLY_BINDING: A free Distributed Virtual Port will be selected and assigned to a Virtual Machine when the Virtual Machine is reconfigured to connect to the portgroup. Instant clones desktop pools/farms only support port group type of early binding. * EPHEMERAL: A Distributed Virtual Port will be created and assigned to a Virtual Machine when the Virtual Machine is powered on, and will be deleted when the Virtual Machine is powered off. An ephemeral portgroup has no limit on the number of ports that can be a part of this portgroup. In cases where the vCenter Server is unavailable the host can create conflict ports in this portgroup to be used by a Virtual Machine at power on. * LATE_BINDING: Deprecated as of vSphere API 5.0 A free DistributedVirtualPort will be selected and assigned to a Virtual Machine when the Virtual Machine is powered on.</value>
        [DataMember(Name="label_type", EmitDefaultValue=false)]
        public LabelTypeEnum? LabelType { get; set; }
        /// <summary>
        /// Network label switch type. * STANDARD_SWITCH: Standard Switch. * DISTRIBUTED_VIRTUAL_SWITCH: Distributed Virtual Switch. * NSX_NETWORK_SWITCH: NSX network Switch.
        /// </summary>
        /// <value>Network label switch type. * STANDARD_SWITCH: Standard Switch. * DISTRIBUTED_VIRTUAL_SWITCH: Distributed Virtual Switch. * NSX_NETWORK_SWITCH: NSX network Switch.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum SwitchTypeEnum
        {
            
            /// <summary>
            /// Enum STANDARDSWITCH for value: STANDARD_SWITCH
            /// </summary>
            [EnumMember(Value = "STANDARD_SWITCH")]
            STANDARDSWITCH = 1,
            
            /// <summary>
            /// Enum DISTRIBUTEDVIRTUALSWITCH for value: DISTRIBUTED_VIRTUAL_SWITCH
            /// </summary>
            [EnumMember(Value = "DISTRIBUTED_VIRTUAL_SWITCH")]
            DISTRIBUTEDVIRTUALSWITCH = 2,
            
            /// <summary>
            /// Enum NSXNETWORKSWITCH for value: NSX_NETWORK_SWITCH
            /// </summary>
            [EnumMember(Value = "NSX_NETWORK_SWITCH")]
            NSXNETWORKSWITCH = 3
        }

        /// <summary>
        /// Network label switch type. * STANDARD_SWITCH: Standard Switch. * DISTRIBUTED_VIRTUAL_SWITCH: Distributed Virtual Switch. * NSX_NETWORK_SWITCH: NSX network Switch.
        /// </summary>
        /// <value>Network label switch type. * STANDARD_SWITCH: Standard Switch. * DISTRIBUTED_VIRTUAL_SWITCH: Distributed Virtual Switch. * NSX_NETWORK_SWITCH: NSX network Switch.</value>
        [DataMember(Name="switch_type", EmitDefaultValue=false)]
        public SwitchTypeEnum? SwitchType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="NetworkLabelInfo" /> class.
        /// </summary>
        /// <param name="availablePorts">Available ports in network label..</param>
        /// <param name="id">Unique ID representing the network label..</param>
        /// <param name="incompatibleReasons">Reasons that may preclude this Network Label from being used in desktoppool/farm configuration..</param>
        /// <param name="labelType">Network label type. * EARLY_BINDING: A free Distributed Virtual Port will be selected and assigned to a Virtual Machine when the Virtual Machine is reconfigured to connect to the portgroup. Instant clones desktop pools/farms only support port group type of early binding. * EPHEMERAL: A Distributed Virtual Port will be created and assigned to a Virtual Machine when the Virtual Machine is powered on, and will be deleted when the Virtual Machine is powered off. An ephemeral portgroup has no limit on the number of ports that can be a part of this portgroup. In cases where the vCenter Server is unavailable the host can create conflict ports in this portgroup to be used by a Virtual Machine at power on. * LATE_BINDING: Deprecated as of vSphere API 5.0 A free DistributedVirtualPort will be selected and assigned to a Virtual Machine when the Virtual Machine is powered on..</param>
        /// <param name="maxPorts">The total number of ports present..</param>
        /// <param name="name">Network label name..</param>
        /// <param name="switchType">Network label switch type. * STANDARD_SWITCH: Standard Switch. * DISTRIBUTED_VIRTUAL_SWITCH: Distributed Virtual Switch. * NSX_NETWORK_SWITCH: NSX network Switch..</param>
        public NetworkLabelInfo(int? availablePorts = default(int?), string id = default(string), List<IncompatibleReasonsEnum> incompatibleReasons = default(List<IncompatibleReasonsEnum>), LabelTypeEnum? labelType = default(LabelTypeEnum?), int? maxPorts = default(int?), string name = default(string), SwitchTypeEnum? switchType = default(SwitchTypeEnum?))
        {
            this.AvailablePorts = availablePorts;
            this.Id = id;
            this.IncompatibleReasons = incompatibleReasons;
            this.LabelType = labelType;
            this.MaxPorts = maxPorts;
            this.Name = name;
            this.SwitchType = switchType;
        }
        
        /// <summary>
        /// Available ports in network label.
        /// </summary>
        /// <value>Available ports in network label.</value>
        [DataMember(Name="available_ports", EmitDefaultValue=false)]
        public int? AvailablePorts { get; set; }

        /// <summary>
        /// Unique ID representing the network label.
        /// </summary>
        /// <value>Unique ID representing the network label.</value>
        [DataMember(Name="id", EmitDefaultValue=false)]
        public string Id { get; set; }



        /// <summary>
        /// The total number of ports present.
        /// </summary>
        /// <value>The total number of ports present.</value>
        [DataMember(Name="max_ports", EmitDefaultValue=false)]
        public int? MaxPorts { get; set; }

        /// <summary>
        /// Network label name.
        /// </summary>
        /// <value>Network label name.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }


        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NetworkLabelInfo {\n");
            sb.Append("  AvailablePorts: ").Append(AvailablePorts).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  IncompatibleReasons: ").Append(IncompatibleReasons).Append("\n");
            sb.Append("  LabelType: ").Append(LabelType).Append("\n");
            sb.Append("  MaxPorts: ").Append(MaxPorts).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  SwitchType: ").Append(SwitchType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as NetworkLabelInfo);
        }

        /// <summary>
        /// Returns true if NetworkLabelInfo instances are equal
        /// </summary>
        /// <param name="input">Instance of NetworkLabelInfo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NetworkLabelInfo input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.AvailablePorts == input.AvailablePorts ||
                    (this.AvailablePorts != null &&
                    this.AvailablePorts.Equals(input.AvailablePorts))
                ) && 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.IncompatibleReasons == input.IncompatibleReasons ||
                    this.IncompatibleReasons != null &&
                    this.IncompatibleReasons.SequenceEqual(input.IncompatibleReasons)
                ) && 
                (
                    this.LabelType == input.LabelType ||
                    (this.LabelType != null &&
                    this.LabelType.Equals(input.LabelType))
                ) && 
                (
                    this.MaxPorts == input.MaxPorts ||
                    (this.MaxPorts != null &&
                    this.MaxPorts.Equals(input.MaxPorts))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.SwitchType == input.SwitchType ||
                    (this.SwitchType != null &&
                    this.SwitchType.Equals(input.SwitchType))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.AvailablePorts != null)
                    hashCode = hashCode * 59 + this.AvailablePorts.GetHashCode();
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.IncompatibleReasons != null)
                    hashCode = hashCode * 59 + this.IncompatibleReasons.GetHashCode();
                if (this.LabelType != null)
                    hashCode = hashCode * 59 + this.LabelType.GetHashCode();
                if (this.MaxPorts != null)
                    hashCode = hashCode * 59 + this.MaxPorts.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.SwitchType != null)
                    hashCode = hashCode * 59 + this.SwitchType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
