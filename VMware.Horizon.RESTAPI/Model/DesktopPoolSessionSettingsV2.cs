/* 
 * Horizon Server API
 *
 * Welcome to the Horizon Server API Reference documentation. This API reference provides comprehensive information about status of all Horizon Server components and resources.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using SwaggerDateConverter = VMware.Horizon.RESTAPI.Client.SwaggerDateConverter;

namespace VMware.Horizon.RESTAPI.Model
{
    /// <summary>
    /// Machine settings applicable when a user logs off or when a desktop pool is no longer keeping a machine as a spare.
    /// </summary>
    [DataContract]
    public partial class DesktopPoolSessionSettingsV2 :  IEquatable<DesktopPoolSessionSettingsV2>
    {
        /// <summary>
        /// Whether machines are to be deleted or refreshed after logoff in case of Floating User Assignment.This is applicable for automated desktops with virtual machines names based onpattern naming. This is not applicable for desktops that are using specified naming since dynamic creation and deletion of VMs is not supported.For Instant clone desktops this setting can only be set to DELETE. Default value is NEVER. * NEVER: Never delete or refresh the machine in the desktop pool. * DELETE: Delete the machine after user logoff. * REFRESH: Refresh the machine after user logoff.
        /// </summary>
        /// <value>Whether machines are to be deleted or refreshed after logoff in case of Floating User Assignment.This is applicable for automated desktops with virtual machines names based onpattern naming. This is not applicable for desktops that are using specified naming since dynamic creation and deletion of VMs is not supported.For Instant clone desktops this setting can only be set to DELETE. Default value is NEVER. * NEVER: Never delete or refresh the machine in the desktop pool. * DELETE: Delete the machine after user logoff. * REFRESH: Refresh the machine after user logoff.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum DeleteOrRefreshMachineAfterLogoffEnum
        {
            
            /// <summary>
            /// Enum NEVER for value: NEVER
            /// </summary>
            [EnumMember(Value = "NEVER")]
            NEVER = 1,
            
            /// <summary>
            /// Enum DELETE for value: DELETE
            /// </summary>
            [EnumMember(Value = "DELETE")]
            DELETE = 2,
            
            /// <summary>
            /// Enum REFRESH for value: REFRESH
            /// </summary>
            [EnumMember(Value = "REFRESH")]
            REFRESH = 3
        }

        /// <summary>
        /// Whether machines are to be deleted or refreshed after logoff in case of Floating User Assignment.This is applicable for automated desktops with virtual machines names based onpattern naming. This is not applicable for desktops that are using specified naming since dynamic creation and deletion of VMs is not supported.For Instant clone desktops this setting can only be set to DELETE. Default value is NEVER. * NEVER: Never delete or refresh the machine in the desktop pool. * DELETE: Delete the machine after user logoff. * REFRESH: Refresh the machine after user logoff.
        /// </summary>
        /// <value>Whether machines are to be deleted or refreshed after logoff in case of Floating User Assignment.This is applicable for automated desktops with virtual machines names based onpattern naming. This is not applicable for desktops that are using specified naming since dynamic creation and deletion of VMs is not supported.For Instant clone desktops this setting can only be set to DELETE. Default value is NEVER. * NEVER: Never delete or refresh the machine in the desktop pool. * DELETE: Delete the machine after user logoff. * REFRESH: Refresh the machine after user logoff.</value>
        [DataMember(Name="delete_or_refresh_machine_after_logoff", EmitDefaultValue=false)]
        public DeleteOrRefreshMachineAfterLogoffEnum DeleteOrRefreshMachineAfterLogoff { get; set; }
        /// <summary>
        /// Log-off policy after disconnected session. Default value is NEVER. * IMMEDIATELY: Immmediately Logoff after user disconnect. * AFTER: Logoff after the specified number of minutes after user disconnect. * NEVER: Do not logoff after user disconnect.
        /// </summary>
        /// <value>Log-off policy after disconnected session. Default value is NEVER. * IMMEDIATELY: Immmediately Logoff after user disconnect. * AFTER: Logoff after the specified number of minutes after user disconnect. * NEVER: Do not logoff after user disconnect.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum DisconnectedSessionTimeoutPolicyEnum
        {
            
            /// <summary>
            /// Enum IMMEDIATELY for value: IMMEDIATELY
            /// </summary>
            [EnumMember(Value = "IMMEDIATELY")]
            IMMEDIATELY = 1,
            
            /// <summary>
            /// Enum AFTER for value: AFTER
            /// </summary>
            [EnumMember(Value = "AFTER")]
            AFTER = 2,
            
            /// <summary>
            /// Enum NEVER for value: NEVER
            /// </summary>
            [EnumMember(Value = "NEVER")]
            NEVER = 3
        }

        /// <summary>
        /// Log-off policy after disconnected session. Default value is NEVER. * IMMEDIATELY: Immmediately Logoff after user disconnect. * AFTER: Logoff after the specified number of minutes after user disconnect. * NEVER: Do not logoff after user disconnect.
        /// </summary>
        /// <value>Log-off policy after disconnected session. Default value is NEVER. * IMMEDIATELY: Immmediately Logoff after user disconnect. * AFTER: Logoff after the specified number of minutes after user disconnect. * NEVER: Do not logoff after user disconnect.</value>
        [DataMember(Name="disconnected_session_timeout_policy", EmitDefaultValue=false)]
        public DisconnectedSessionTimeoutPolicyEnum DisconnectedSessionTimeoutPolicy { get; set; }
        /// <summary>
        /// Application empty session timeout policy. Default value is AFTER. * IMMEDIATE: Empty session will be disconnected immediately. * NEVER: Empty session will never disconnected. * AFTER: Empty session will be disconnected after specified number of minutes.
        /// </summary>
        /// <value>Application empty session timeout policy. Default value is AFTER. * IMMEDIATE: Empty session will be disconnected immediately. * NEVER: Empty session will never disconnected. * AFTER: Empty session will be disconnected after specified number of minutes.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum EmptySessionTimeoutPolicyEnum
        {
            
            /// <summary>
            /// Enum IMMEDIATE for value: IMMEDIATE
            /// </summary>
            [EnumMember(Value = "IMMEDIATE")]
            IMMEDIATE = 1,
            
            /// <summary>
            /// Enum NEVER for value: NEVER
            /// </summary>
            [EnumMember(Value = "NEVER")]
            NEVER = 2,
            
            /// <summary>
            /// Enum AFTER for value: AFTER
            /// </summary>
            [EnumMember(Value = "AFTER")]
            AFTER = 3
        }

        /// <summary>
        /// Application empty session timeout policy. Default value is AFTER. * IMMEDIATE: Empty session will be disconnected immediately. * NEVER: Empty session will never disconnected. * AFTER: Empty session will be disconnected after specified number of minutes.
        /// </summary>
        /// <value>Application empty session timeout policy. Default value is AFTER. * IMMEDIATE: Empty session will be disconnected immediately. * NEVER: Empty session will never disconnected. * AFTER: Empty session will be disconnected after specified number of minutes.</value>
        [DataMember(Name="empty_session_timeout_policy", EmitDefaultValue=false)]
        public EmptySessionTimeoutPolicyEnum EmptySessionTimeoutPolicy { get; set; }
        /// <summary>
        /// Power policy for the machines in the desktop pool after logoff. This setting is only relevant for managed machines.Default value is TAKE_NO_POWER_ACTION.For Instant clone desktops this setting can only be set to ALWAYS_POWERED_ON. * TAKE_NO_POWER_ACTION: No action will be taken when user logs off. * ALWAYS_POWERED_ON: Ensure machines in the Desktop pool are always powered on.The connection server will monitor and power on machines as necessary. * SUSPEND: Suspend when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines. * POWER_OFF: Power off when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines.
        /// </summary>
        /// <value>Power policy for the machines in the desktop pool after logoff. This setting is only relevant for managed machines.Default value is TAKE_NO_POWER_ACTION.For Instant clone desktops this setting can only be set to ALWAYS_POWERED_ON. * TAKE_NO_POWER_ACTION: No action will be taken when user logs off. * ALWAYS_POWERED_ON: Ensure machines in the Desktop pool are always powered on.The connection server will monitor and power on machines as necessary. * SUSPEND: Suspend when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines. * POWER_OFF: Power off when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum PowerPolicyEnum
        {
            
            /// <summary>
            /// Enum TAKENOPOWERACTION for value: TAKE_NO_POWER_ACTION
            /// </summary>
            [EnumMember(Value = "TAKE_NO_POWER_ACTION")]
            TAKENOPOWERACTION = 1,
            
            /// <summary>
            /// Enum ALWAYSPOWEREDON for value: ALWAYS_POWERED_ON
            /// </summary>
            [EnumMember(Value = "ALWAYS_POWERED_ON")]
            ALWAYSPOWEREDON = 2,
            
            /// <summary>
            /// Enum SUSPEND for value: SUSPEND
            /// </summary>
            [EnumMember(Value = "SUSPEND")]
            SUSPEND = 3,
            
            /// <summary>
            /// Enum POWEROFF for value: POWER_OFF
            /// </summary>
            [EnumMember(Value = "POWER_OFF")]
            POWEROFF = 4
        }

        /// <summary>
        /// Power policy for the machines in the desktop pool after logoff. This setting is only relevant for managed machines.Default value is TAKE_NO_POWER_ACTION.For Instant clone desktops this setting can only be set to ALWAYS_POWERED_ON. * TAKE_NO_POWER_ACTION: No action will be taken when user logs off. * ALWAYS_POWERED_ON: Ensure machines in the Desktop pool are always powered on.The connection server will monitor and power on machines as necessary. * SUSPEND: Suspend when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines. * POWER_OFF: Power off when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines.
        /// </summary>
        /// <value>Power policy for the machines in the desktop pool after logoff. This setting is only relevant for managed machines.Default value is TAKE_NO_POWER_ACTION.For Instant clone desktops this setting can only be set to ALWAYS_POWERED_ON. * TAKE_NO_POWER_ACTION: No action will be taken when user logs off. * ALWAYS_POWERED_ON: Ensure machines in the Desktop pool are always powered on.The connection server will monitor and power on machines as necessary. * SUSPEND: Suspend when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines. * POWER_OFF: Power off when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines.</value>
        [DataMember(Name="power_policy", EmitDefaultValue=false)]
        public PowerPolicyEnum PowerPolicy { get; set; }
        /// <summary>
        /// Application pre-launch session timeout policy. Default value is AFTER. * NEVER: Pre-launched session is never disconnected. * AFTER: Pre-launched session is disconnected after specified number of minutes.
        /// </summary>
        /// <value>Application pre-launch session timeout policy. Default value is AFTER. * NEVER: Pre-launched session is never disconnected. * AFTER: Pre-launched session is disconnected after specified number of minutes.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum PreLaunchSessionTimeoutPolicyEnum
        {
            
            /// <summary>
            /// Enum NEVER for value: NEVER
            /// </summary>
            [EnumMember(Value = "NEVER")]
            NEVER = 1,
            
            /// <summary>
            /// Enum AFTER for value: AFTER
            /// </summary>
            [EnumMember(Value = "AFTER")]
            AFTER = 2
        }

        /// <summary>
        /// Application pre-launch session timeout policy. Default value is AFTER. * NEVER: Pre-launched session is never disconnected. * AFTER: Pre-launched session is disconnected after specified number of minutes.
        /// </summary>
        /// <value>Application pre-launch session timeout policy. Default value is AFTER. * NEVER: Pre-launched session is never disconnected. * AFTER: Pre-launched session is disconnected after specified number of minutes.</value>
        [DataMember(Name="pre_launch_session_timeout_policy", EmitDefaultValue=false)]
        public PreLaunchSessionTimeoutPolicyEnum? PreLaunchSessionTimeoutPolicy { get; set; }
        /// <summary>
        /// Whether and when to refresh the OS disks for dedicated-assignment, linked-clone and instant-clone machines.Default value is NEVER. * NEVER: The OS disk is never refreshed. * ALWAYS: The OS disk is refreshed every time the user logs off. * EVERY: The OS disk is refreshed at regular intervals of a specified number of days. The number of days is counted from the last refresh, or from the initial provisioning if no refresh has occurred yet. For example, if the specified value is 3 days, and three days have passed since the last refresh, the machine is refreshed after the user logs off. * AT_SIZE: The OS disk is refreshed when its current size reaches a specified percentage of its maximum allowable size. The maximum size of a linked clone&#39;s OS disk is the size of the replica&#39;s OS disk. With this option, the size of the linked clone&#39;s OS disk in the datastore is compared to maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.
        /// </summary>
        /// <value>Whether and when to refresh the OS disks for dedicated-assignment, linked-clone and instant-clone machines.Default value is NEVER. * NEVER: The OS disk is never refreshed. * ALWAYS: The OS disk is refreshed every time the user logs off. * EVERY: The OS disk is refreshed at regular intervals of a specified number of days. The number of days is counted from the last refresh, or from the initial provisioning if no refresh has occurred yet. For example, if the specified value is 3 days, and three days have passed since the last refresh, the machine is refreshed after the user logs off. * AT_SIZE: The OS disk is refreshed when its current size reaches a specified percentage of its maximum allowable size. The maximum size of a linked clone&#39;s OS disk is the size of the replica&#39;s OS disk. With this option, the size of the linked clone&#39;s OS disk in the datastore is compared to maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RefreshOsDiskAfterLogoffEnum
        {
            
            /// <summary>
            /// Enum NEVER for value: NEVER
            /// </summary>
            [EnumMember(Value = "NEVER")]
            NEVER = 1,
            
            /// <summary>
            /// Enum ALWAYS for value: ALWAYS
            /// </summary>
            [EnumMember(Value = "ALWAYS")]
            ALWAYS = 2,
            
            /// <summary>
            /// Enum EVERY for value: EVERY
            /// </summary>
            [EnumMember(Value = "EVERY")]
            EVERY = 3,
            
            /// <summary>
            /// Enum ATSIZE for value: AT_SIZE
            /// </summary>
            [EnumMember(Value = "AT_SIZE")]
            ATSIZE = 4
        }

        /// <summary>
        /// Whether and when to refresh the OS disks for dedicated-assignment, linked-clone and instant-clone machines.Default value is NEVER. * NEVER: The OS disk is never refreshed. * ALWAYS: The OS disk is refreshed every time the user logs off. * EVERY: The OS disk is refreshed at regular intervals of a specified number of days. The number of days is counted from the last refresh, or from the initial provisioning if no refresh has occurred yet. For example, if the specified value is 3 days, and three days have passed since the last refresh, the machine is refreshed after the user logs off. * AT_SIZE: The OS disk is refreshed when its current size reaches a specified percentage of its maximum allowable size. The maximum size of a linked clone&#39;s OS disk is the size of the replica&#39;s OS disk. With this option, the size of the linked clone&#39;s OS disk in the datastore is compared to maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.
        /// </summary>
        /// <value>Whether and when to refresh the OS disks for dedicated-assignment, linked-clone and instant-clone machines.Default value is NEVER. * NEVER: The OS disk is never refreshed. * ALWAYS: The OS disk is refreshed every time the user logs off. * EVERY: The OS disk is refreshed at regular intervals of a specified number of days. The number of days is counted from the last refresh, or from the initial provisioning if no refresh has occurred yet. For example, if the specified value is 3 days, and three days have passed since the last refresh, the machine is refreshed after the user logs off. * AT_SIZE: The OS disk is refreshed when its current size reaches a specified percentage of its maximum allowable size. The maximum size of a linked clone&#39;s OS disk is the size of the replica&#39;s OS disk. With this option, the size of the linked clone&#39;s OS disk in the datastore is compared to maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.</value>
        [DataMember(Name="refresh_os_disk_after_logoff", EmitDefaultValue=false)]
        public RefreshOsDiskAfterLogoffEnum RefreshOsDiskAfterLogoff { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="DesktopPoolSessionSettingsV2" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected DesktopPoolSessionSettingsV2() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DesktopPoolSessionSettingsV2" /> class.
        /// </summary>
        /// <param name="allowMultipleSessionsPerUser">Indicates whether multiple sessions are allowed per user in case of Floating User Assignment. Default value is false. (required).</param>
        /// <param name="allowUsersToResetMachines">Indicates whether the user can be allowed to reset or restart their machines. Default value is false. (required).</param>
        /// <param name="deleteOrRefreshMachineAfterLogoff">Whether machines are to be deleted or refreshed after logoff in case of Floating User Assignment.This is applicable for automated desktops with virtual machines names based onpattern naming. This is not applicable for desktops that are using specified naming since dynamic creation and deletion of VMs is not supported.For Instant clone desktops this setting can only be set to DELETE. Default value is NEVER. * NEVER: Never delete or refresh the machine in the desktop pool. * DELETE: Delete the machine after user logoff. * REFRESH: Refresh the machine after user logoff. (required).</param>
        /// <param name="disconnectedSessionTimeoutMinutes">Disconnected sessions timeout (in minutes). Will be set when disconnected_session_timeout_policy is set to AFTER..</param>
        /// <param name="disconnectedSessionTimeoutPolicy">Log-off policy after disconnected session. Default value is NEVER. * IMMEDIATELY: Immmediately Logoff after user disconnect. * AFTER: Logoff after the specified number of minutes after user disconnect. * NEVER: Do not logoff after user disconnect. (required).</param>
        /// <param name="emptySessionTimeoutMinutes">Application empty session timeout (in minutes). An empty session (that has no remote-ablewindow) is disconnected after the timeout. Default value is 1.Will be set when the empty_session_timeout_policy set to AFTER..</param>
        /// <param name="emptySessionTimeoutPolicy">Application empty session timeout policy. Default value is AFTER. * IMMEDIATE: Empty session will be disconnected immediately. * NEVER: Empty session will never disconnected. * AFTER: Empty session will be disconnected after specified number of minutes. (required).</param>
        /// <param name="logoffAfterTimeout">Indicates whether the empty application sessions are logged off (true) or disconnected (false) after timeout.Default value is false. (required).</param>
        /// <param name="powerPolicy">Power policy for the machines in the desktop pool after logoff. This setting is only relevant for managed machines.Default value is TAKE_NO_POWER_ACTION.For Instant clone desktops this setting can only be set to ALWAYS_POWERED_ON. * TAKE_NO_POWER_ACTION: No action will be taken when user logs off. * ALWAYS_POWERED_ON: Ensure machines in the Desktop pool are always powered on.The connection server will monitor and power on machines as necessary. * SUSPEND: Suspend when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines. * POWER_OFF: Power off when a user logs off or when desktop pool is no longer keeping a machine as a spare.This does not affect spare and newly provisioned machines. (required).</param>
        /// <param name="preLaunchSessionTimeoutMinutes">Application pre-launch session timeout (in minutes). A pre-launch session is disconnected after the timeout. Default value is 10.Will be required when the pre-launch session timeout policy is set to AFTER..</param>
        /// <param name="preLaunchSessionTimeoutPolicy">Application pre-launch session timeout policy. Default value is AFTER. * NEVER: Pre-launched session is never disconnected. * AFTER: Pre-launched session is disconnected after specified number of minutes..</param>
        /// <param name="refreshOsDiskAfterLogoff">Whether and when to refresh the OS disks for dedicated-assignment, linked-clone and instant-clone machines.Default value is NEVER. * NEVER: The OS disk is never refreshed. * ALWAYS: The OS disk is refreshed every time the user logs off. * EVERY: The OS disk is refreshed at regular intervals of a specified number of days. The number of days is counted from the last refresh, or from the initial provisioning if no refresh has occurred yet. For example, if the specified value is 3 days, and three days have passed since the last refresh, the machine is refreshed after the user logs off. * AT_SIZE: The OS disk is refreshed when its current size reaches a specified percentage of its maximum allowable size. The maximum size of a linked clone&#39;s OS disk is the size of the replica&#39;s OS disk. With this option, the size of the linked clone&#39;s OS disk in the datastore is compared to maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system. (required).</param>
        /// <param name="refreshPeriodDaysForReplicaOsDisk">Regular interval at which to refresh the OS disk. Will be set when refresh_os_disk_after_logoff set to EVERY. (required).</param>
        /// <param name="refreshThresholdPercentageForReplicaOsDisk">With the &#39;AT_SIZE&#39; option for refreshOsDiskAfterLogoff, the size of the linked clone&#39;s OS diskin the datastore is compared to its maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.Will be set when refresh_os_disk_after_logoff set to AT_SIZE. (required).</param>
        public DesktopPoolSessionSettingsV2(bool? allowMultipleSessionsPerUser = default(bool?), bool? allowUsersToResetMachines = default(bool?), DeleteOrRefreshMachineAfterLogoffEnum deleteOrRefreshMachineAfterLogoff = default(DeleteOrRefreshMachineAfterLogoffEnum), int? disconnectedSessionTimeoutMinutes = default(int?), DisconnectedSessionTimeoutPolicyEnum disconnectedSessionTimeoutPolicy = default(DisconnectedSessionTimeoutPolicyEnum), int? emptySessionTimeoutMinutes = default(int?), EmptySessionTimeoutPolicyEnum emptySessionTimeoutPolicy = default(EmptySessionTimeoutPolicyEnum), bool? logoffAfterTimeout = default(bool?), PowerPolicyEnum powerPolicy = default(PowerPolicyEnum), int? preLaunchSessionTimeoutMinutes = default(int?), PreLaunchSessionTimeoutPolicyEnum? preLaunchSessionTimeoutPolicy = default(PreLaunchSessionTimeoutPolicyEnum?), RefreshOsDiskAfterLogoffEnum refreshOsDiskAfterLogoff = default(RefreshOsDiskAfterLogoffEnum), int? refreshPeriodDaysForReplicaOsDisk = default(int?), int? refreshThresholdPercentageForReplicaOsDisk = default(int?))
        {
            // to ensure "allowMultipleSessionsPerUser" is required (not null)
            if (allowMultipleSessionsPerUser == null)
            {
                throw new InvalidDataException("allowMultipleSessionsPerUser is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.AllowMultipleSessionsPerUser = allowMultipleSessionsPerUser;
            }
            // to ensure "allowUsersToResetMachines" is required (not null)
            if (allowUsersToResetMachines == null)
            {
                throw new InvalidDataException("allowUsersToResetMachines is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.AllowUsersToResetMachines = allowUsersToResetMachines;
            }
            // to ensure "deleteOrRefreshMachineAfterLogoff" is required (not null)
            if (deleteOrRefreshMachineAfterLogoff == null)
            {
                throw new InvalidDataException("deleteOrRefreshMachineAfterLogoff is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.DeleteOrRefreshMachineAfterLogoff = deleteOrRefreshMachineAfterLogoff;
            }
            // to ensure "disconnectedSessionTimeoutPolicy" is required (not null)
            if (disconnectedSessionTimeoutPolicy == null)
            {
                throw new InvalidDataException("disconnectedSessionTimeoutPolicy is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.DisconnectedSessionTimeoutPolicy = disconnectedSessionTimeoutPolicy;
            }
            // to ensure "emptySessionTimeoutPolicy" is required (not null)
            if (emptySessionTimeoutPolicy == null)
            {
                throw new InvalidDataException("emptySessionTimeoutPolicy is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.EmptySessionTimeoutPolicy = emptySessionTimeoutPolicy;
            }
            // to ensure "logoffAfterTimeout" is required (not null)
            if (logoffAfterTimeout == null)
            {
                throw new InvalidDataException("logoffAfterTimeout is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.LogoffAfterTimeout = logoffAfterTimeout;
            }
            // to ensure "powerPolicy" is required (not null)
            if (powerPolicy == null)
            {
                throw new InvalidDataException("powerPolicy is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.PowerPolicy = powerPolicy;
            }
            // to ensure "refreshOsDiskAfterLogoff" is required (not null)
            if (refreshOsDiskAfterLogoff == null)
            {
                throw new InvalidDataException("refreshOsDiskAfterLogoff is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.RefreshOsDiskAfterLogoff = refreshOsDiskAfterLogoff;
            }
            // to ensure "refreshPeriodDaysForReplicaOsDisk" is required (not null)
            if (refreshPeriodDaysForReplicaOsDisk == null)
            {
                throw new InvalidDataException("refreshPeriodDaysForReplicaOsDisk is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.RefreshPeriodDaysForReplicaOsDisk = refreshPeriodDaysForReplicaOsDisk;
            }
            // to ensure "refreshThresholdPercentageForReplicaOsDisk" is required (not null)
            if (refreshThresholdPercentageForReplicaOsDisk == null)
            {
                throw new InvalidDataException("refreshThresholdPercentageForReplicaOsDisk is a required property for DesktopPoolSessionSettingsV2 and cannot be null");
            }
            else
            {
                this.RefreshThresholdPercentageForReplicaOsDisk = refreshThresholdPercentageForReplicaOsDisk;
            }
            this.DisconnectedSessionTimeoutMinutes = disconnectedSessionTimeoutMinutes;
            this.EmptySessionTimeoutMinutes = emptySessionTimeoutMinutes;
            this.PreLaunchSessionTimeoutMinutes = preLaunchSessionTimeoutMinutes;
            this.PreLaunchSessionTimeoutPolicy = preLaunchSessionTimeoutPolicy;
        }
        
        /// <summary>
        /// Indicates whether multiple sessions are allowed per user in case of Floating User Assignment. Default value is false.
        /// </summary>
        /// <value>Indicates whether multiple sessions are allowed per user in case of Floating User Assignment. Default value is false.</value>
        [DataMember(Name="allow_multiple_sessions_per_user", EmitDefaultValue=false)]
        public bool? AllowMultipleSessionsPerUser { get; set; }

        /// <summary>
        /// Indicates whether the user can be allowed to reset or restart their machines. Default value is false.
        /// </summary>
        /// <value>Indicates whether the user can be allowed to reset or restart their machines. Default value is false.</value>
        [DataMember(Name="allow_users_to_reset_machines", EmitDefaultValue=false)]
        public bool? AllowUsersToResetMachines { get; set; }


        /// <summary>
        /// Disconnected sessions timeout (in minutes). Will be set when disconnected_session_timeout_policy is set to AFTER.
        /// </summary>
        /// <value>Disconnected sessions timeout (in minutes). Will be set when disconnected_session_timeout_policy is set to AFTER.</value>
        [DataMember(Name="disconnected_session_timeout_minutes", EmitDefaultValue=false)]
        public int? DisconnectedSessionTimeoutMinutes { get; set; }


        /// <summary>
        /// Application empty session timeout (in minutes). An empty session (that has no remote-ablewindow) is disconnected after the timeout. Default value is 1.Will be set when the empty_session_timeout_policy set to AFTER.
        /// </summary>
        /// <value>Application empty session timeout (in minutes). An empty session (that has no remote-ablewindow) is disconnected after the timeout. Default value is 1.Will be set when the empty_session_timeout_policy set to AFTER.</value>
        [DataMember(Name="empty_session_timeout_minutes", EmitDefaultValue=false)]
        public int? EmptySessionTimeoutMinutes { get; set; }


        /// <summary>
        /// Indicates whether the empty application sessions are logged off (true) or disconnected (false) after timeout.Default value is false.
        /// </summary>
        /// <value>Indicates whether the empty application sessions are logged off (true) or disconnected (false) after timeout.Default value is false.</value>
        [DataMember(Name="logoff_after_timeout", EmitDefaultValue=false)]
        public bool? LogoffAfterTimeout { get; set; }


        /// <summary>
        /// Application pre-launch session timeout (in minutes). A pre-launch session is disconnected after the timeout. Default value is 10.Will be required when the pre-launch session timeout policy is set to AFTER.
        /// </summary>
        /// <value>Application pre-launch session timeout (in minutes). A pre-launch session is disconnected after the timeout. Default value is 10.Will be required when the pre-launch session timeout policy is set to AFTER.</value>
        [DataMember(Name="pre_launch_session_timeout_minutes", EmitDefaultValue=false)]
        public int? PreLaunchSessionTimeoutMinutes { get; set; }



        /// <summary>
        /// Regular interval at which to refresh the OS disk. Will be set when refresh_os_disk_after_logoff set to EVERY.
        /// </summary>
        /// <value>Regular interval at which to refresh the OS disk. Will be set when refresh_os_disk_after_logoff set to EVERY.</value>
        [DataMember(Name="refresh_period_days_for_replica_os_disk", EmitDefaultValue=false)]
        public int? RefreshPeriodDaysForReplicaOsDisk { get; set; }

        /// <summary>
        /// With the &#39;AT_SIZE&#39; option for refreshOsDiskAfterLogoff, the size of the linked clone&#39;s OS diskin the datastore is compared to its maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.Will be set when refresh_os_disk_after_logoff set to AT_SIZE.
        /// </summary>
        /// <value>With the &#39;AT_SIZE&#39; option for refreshOsDiskAfterLogoff, the size of the linked clone&#39;s OS diskin the datastore is compared to its maximum allowable size. This disk-utilization percentage does not reflect disk usage that you might see inside the machine&#39;s guest operating system.Will be set when refresh_os_disk_after_logoff set to AT_SIZE.</value>
        [DataMember(Name="refresh_threshold_percentage_for_replica_os_disk", EmitDefaultValue=false)]
        public int? RefreshThresholdPercentageForReplicaOsDisk { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DesktopPoolSessionSettingsV2 {\n");
            sb.Append("  AllowMultipleSessionsPerUser: ").Append(AllowMultipleSessionsPerUser).Append("\n");
            sb.Append("  AllowUsersToResetMachines: ").Append(AllowUsersToResetMachines).Append("\n");
            sb.Append("  DeleteOrRefreshMachineAfterLogoff: ").Append(DeleteOrRefreshMachineAfterLogoff).Append("\n");
            sb.Append("  DisconnectedSessionTimeoutMinutes: ").Append(DisconnectedSessionTimeoutMinutes).Append("\n");
            sb.Append("  DisconnectedSessionTimeoutPolicy: ").Append(DisconnectedSessionTimeoutPolicy).Append("\n");
            sb.Append("  EmptySessionTimeoutMinutes: ").Append(EmptySessionTimeoutMinutes).Append("\n");
            sb.Append("  EmptySessionTimeoutPolicy: ").Append(EmptySessionTimeoutPolicy).Append("\n");
            sb.Append("  LogoffAfterTimeout: ").Append(LogoffAfterTimeout).Append("\n");
            sb.Append("  PowerPolicy: ").Append(PowerPolicy).Append("\n");
            sb.Append("  PreLaunchSessionTimeoutMinutes: ").Append(PreLaunchSessionTimeoutMinutes).Append("\n");
            sb.Append("  PreLaunchSessionTimeoutPolicy: ").Append(PreLaunchSessionTimeoutPolicy).Append("\n");
            sb.Append("  RefreshOsDiskAfterLogoff: ").Append(RefreshOsDiskAfterLogoff).Append("\n");
            sb.Append("  RefreshPeriodDaysForReplicaOsDisk: ").Append(RefreshPeriodDaysForReplicaOsDisk).Append("\n");
            sb.Append("  RefreshThresholdPercentageForReplicaOsDisk: ").Append(RefreshThresholdPercentageForReplicaOsDisk).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DesktopPoolSessionSettingsV2);
        }

        /// <summary>
        /// Returns true if DesktopPoolSessionSettingsV2 instances are equal
        /// </summary>
        /// <param name="input">Instance of DesktopPoolSessionSettingsV2 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DesktopPoolSessionSettingsV2 input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.AllowMultipleSessionsPerUser == input.AllowMultipleSessionsPerUser ||
                    (this.AllowMultipleSessionsPerUser != null &&
                    this.AllowMultipleSessionsPerUser.Equals(input.AllowMultipleSessionsPerUser))
                ) && 
                (
                    this.AllowUsersToResetMachines == input.AllowUsersToResetMachines ||
                    (this.AllowUsersToResetMachines != null &&
                    this.AllowUsersToResetMachines.Equals(input.AllowUsersToResetMachines))
                ) && 
                (
                    this.DeleteOrRefreshMachineAfterLogoff == input.DeleteOrRefreshMachineAfterLogoff ||
                    (this.DeleteOrRefreshMachineAfterLogoff != null &&
                    this.DeleteOrRefreshMachineAfterLogoff.Equals(input.DeleteOrRefreshMachineAfterLogoff))
                ) && 
                (
                    this.DisconnectedSessionTimeoutMinutes == input.DisconnectedSessionTimeoutMinutes ||
                    (this.DisconnectedSessionTimeoutMinutes != null &&
                    this.DisconnectedSessionTimeoutMinutes.Equals(input.DisconnectedSessionTimeoutMinutes))
                ) && 
                (
                    this.DisconnectedSessionTimeoutPolicy == input.DisconnectedSessionTimeoutPolicy ||
                    (this.DisconnectedSessionTimeoutPolicy != null &&
                    this.DisconnectedSessionTimeoutPolicy.Equals(input.DisconnectedSessionTimeoutPolicy))
                ) && 
                (
                    this.EmptySessionTimeoutMinutes == input.EmptySessionTimeoutMinutes ||
                    (this.EmptySessionTimeoutMinutes != null &&
                    this.EmptySessionTimeoutMinutes.Equals(input.EmptySessionTimeoutMinutes))
                ) && 
                (
                    this.EmptySessionTimeoutPolicy == input.EmptySessionTimeoutPolicy ||
                    (this.EmptySessionTimeoutPolicy != null &&
                    this.EmptySessionTimeoutPolicy.Equals(input.EmptySessionTimeoutPolicy))
                ) && 
                (
                    this.LogoffAfterTimeout == input.LogoffAfterTimeout ||
                    (this.LogoffAfterTimeout != null &&
                    this.LogoffAfterTimeout.Equals(input.LogoffAfterTimeout))
                ) && 
                (
                    this.PowerPolicy == input.PowerPolicy ||
                    (this.PowerPolicy != null &&
                    this.PowerPolicy.Equals(input.PowerPolicy))
                ) && 
                (
                    this.PreLaunchSessionTimeoutMinutes == input.PreLaunchSessionTimeoutMinutes ||
                    (this.PreLaunchSessionTimeoutMinutes != null &&
                    this.PreLaunchSessionTimeoutMinutes.Equals(input.PreLaunchSessionTimeoutMinutes))
                ) && 
                (
                    this.PreLaunchSessionTimeoutPolicy == input.PreLaunchSessionTimeoutPolicy ||
                    (this.PreLaunchSessionTimeoutPolicy != null &&
                    this.PreLaunchSessionTimeoutPolicy.Equals(input.PreLaunchSessionTimeoutPolicy))
                ) && 
                (
                    this.RefreshOsDiskAfterLogoff == input.RefreshOsDiskAfterLogoff ||
                    (this.RefreshOsDiskAfterLogoff != null &&
                    this.RefreshOsDiskAfterLogoff.Equals(input.RefreshOsDiskAfterLogoff))
                ) && 
                (
                    this.RefreshPeriodDaysForReplicaOsDisk == input.RefreshPeriodDaysForReplicaOsDisk ||
                    (this.RefreshPeriodDaysForReplicaOsDisk != null &&
                    this.RefreshPeriodDaysForReplicaOsDisk.Equals(input.RefreshPeriodDaysForReplicaOsDisk))
                ) && 
                (
                    this.RefreshThresholdPercentageForReplicaOsDisk == input.RefreshThresholdPercentageForReplicaOsDisk ||
                    (this.RefreshThresholdPercentageForReplicaOsDisk != null &&
                    this.RefreshThresholdPercentageForReplicaOsDisk.Equals(input.RefreshThresholdPercentageForReplicaOsDisk))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.AllowMultipleSessionsPerUser != null)
                    hashCode = hashCode * 59 + this.AllowMultipleSessionsPerUser.GetHashCode();
                if (this.AllowUsersToResetMachines != null)
                    hashCode = hashCode * 59 + this.AllowUsersToResetMachines.GetHashCode();
                if (this.DeleteOrRefreshMachineAfterLogoff != null)
                    hashCode = hashCode * 59 + this.DeleteOrRefreshMachineAfterLogoff.GetHashCode();
                if (this.DisconnectedSessionTimeoutMinutes != null)
                    hashCode = hashCode * 59 + this.DisconnectedSessionTimeoutMinutes.GetHashCode();
                if (this.DisconnectedSessionTimeoutPolicy != null)
                    hashCode = hashCode * 59 + this.DisconnectedSessionTimeoutPolicy.GetHashCode();
                if (this.EmptySessionTimeoutMinutes != null)
                    hashCode = hashCode * 59 + this.EmptySessionTimeoutMinutes.GetHashCode();
                if (this.EmptySessionTimeoutPolicy != null)
                    hashCode = hashCode * 59 + this.EmptySessionTimeoutPolicy.GetHashCode();
                if (this.LogoffAfterTimeout != null)
                    hashCode = hashCode * 59 + this.LogoffAfterTimeout.GetHashCode();
                if (this.PowerPolicy != null)
                    hashCode = hashCode * 59 + this.PowerPolicy.GetHashCode();
                if (this.PreLaunchSessionTimeoutMinutes != null)
                    hashCode = hashCode * 59 + this.PreLaunchSessionTimeoutMinutes.GetHashCode();
                if (this.PreLaunchSessionTimeoutPolicy != null)
                    hashCode = hashCode * 59 + this.PreLaunchSessionTimeoutPolicy.GetHashCode();
                if (this.RefreshOsDiskAfterLogoff != null)
                    hashCode = hashCode * 59 + this.RefreshOsDiskAfterLogoff.GetHashCode();
                if (this.RefreshPeriodDaysForReplicaOsDisk != null)
                    hashCode = hashCode * 59 + this.RefreshPeriodDaysForReplicaOsDisk.GetHashCode();
                if (this.RefreshThresholdPercentageForReplicaOsDisk != null)
                    hashCode = hashCode * 59 + this.RefreshThresholdPercentageForReplicaOsDisk.GetHashCode();
                return hashCode;
            }
        }
    }

}
