/* 
 * Horizon Server API
 *
 * Welcome to the Horizon Server API Reference documentation. This API reference provides comprehensive information about status of all Horizon Server components and resources.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using SwaggerDateConverter = VMware.Horizon.RESTAPI.Client.SwaggerDateConverter;

namespace VMware.Horizon.RESTAPI.Model
{
    /// <summary>
    /// Specification applicable when deleting machines.
    /// </summary>
    [DataContract]
    public partial class MachineDeleteData :  IEquatable<MachineDeleteData>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineDeleteData" /> class.
        /// </summary>
        /// <param name="allowDeleteFromMultiDesktopPools">Determines whether the machines from different desktop pools can be deleted. This defaults to false in which case only machines belonging to single desktop pool can be deleted. If true, machines from different desktop pools can be deleted..</param>
        /// <param name="archiveDatastoreId">Determines the datastore where the persistent user disk will be saved for future use. Both this as well as the archiveDatastorePathId need to be set. If this is unset and archivePersistentDisk is specified, the persistent disk is archived in place..</param>
        /// <param name="archiveDatastorePathId">Determines the location in the datastore where the persistent user disk will be saved for future use. If this is set, then archiveDatastoreId also needs to be specified.If this is unset and archivePersistentDisk is specified, the persistent disk is archived in place..</param>
        /// <param name="archivePersistentDisk">Determines whether to detach the persistent user disk and save it for future use. This can only be specified for linked-clone desktops with redirectWindowsProfile enabled, in which case it defaults to true. .</param>
        /// <param name="deleteFromDisk">Determines whether the Machine VM should be deleted from vCenter Server. This is only applicable for managed machines. This must always be true for machines in linked and instant clone desktops. This defaults to true for linked and instant clone machines and false for all other types. If this is true, then machine being deleted must not have any active user session, otherwise delete operation would fail..</param>
        /// <param name="forceLogoffSession">Determines whether active session on the machine to be logged off before deletion. This is only applicable for managed machines. If true, active session on the machine will be logged off before Machine delete. Otherwise,it will result in an exception. .</param>
        public MachineDeleteData(bool? allowDeleteFromMultiDesktopPools = default(bool?), string archiveDatastoreId = default(string), string archiveDatastorePathId = default(string), bool? archivePersistentDisk = default(bool?), bool? deleteFromDisk = default(bool?), bool? forceLogoffSession = default(bool?))
        {
            this.AllowDeleteFromMultiDesktopPools = allowDeleteFromMultiDesktopPools;
            this.ArchiveDatastoreId = archiveDatastoreId;
            this.ArchiveDatastorePathId = archiveDatastorePathId;
            this.ArchivePersistentDisk = archivePersistentDisk;
            this.DeleteFromDisk = deleteFromDisk;
            this.ForceLogoffSession = forceLogoffSession;
        }
        
        /// <summary>
        /// Determines whether the machines from different desktop pools can be deleted. This defaults to false in which case only machines belonging to single desktop pool can be deleted. If true, machines from different desktop pools can be deleted.
        /// </summary>
        /// <value>Determines whether the machines from different desktop pools can be deleted. This defaults to false in which case only machines belonging to single desktop pool can be deleted. If true, machines from different desktop pools can be deleted.</value>
        [DataMember(Name="allow_delete_from_multi_desktop_pools", EmitDefaultValue=false)]
        public bool? AllowDeleteFromMultiDesktopPools { get; set; }

        /// <summary>
        /// Determines the datastore where the persistent user disk will be saved for future use. Both this as well as the archiveDatastorePathId need to be set. If this is unset and archivePersistentDisk is specified, the persistent disk is archived in place.
        /// </summary>
        /// <value>Determines the datastore where the persistent user disk will be saved for future use. Both this as well as the archiveDatastorePathId need to be set. If this is unset and archivePersistentDisk is specified, the persistent disk is archived in place.</value>
        [DataMember(Name="archive_datastore_id", EmitDefaultValue=false)]
        public string ArchiveDatastoreId { get; set; }

        /// <summary>
        /// Determines the location in the datastore where the persistent user disk will be saved for future use. If this is set, then archiveDatastoreId also needs to be specified.If this is unset and archivePersistentDisk is specified, the persistent disk is archived in place.
        /// </summary>
        /// <value>Determines the location in the datastore where the persistent user disk will be saved for future use. If this is set, then archiveDatastoreId also needs to be specified.If this is unset and archivePersistentDisk is specified, the persistent disk is archived in place.</value>
        [DataMember(Name="archive_datastore_path_id", EmitDefaultValue=false)]
        public string ArchiveDatastorePathId { get; set; }

        /// <summary>
        /// Determines whether to detach the persistent user disk and save it for future use. This can only be specified for linked-clone desktops with redirectWindowsProfile enabled, in which case it defaults to true. 
        /// </summary>
        /// <value>Determines whether to detach the persistent user disk and save it for future use. This can only be specified for linked-clone desktops with redirectWindowsProfile enabled, in which case it defaults to true. </value>
        [DataMember(Name="archive_persistent_disk", EmitDefaultValue=false)]
        public bool? ArchivePersistentDisk { get; set; }

        /// <summary>
        /// Determines whether the Machine VM should be deleted from vCenter Server. This is only applicable for managed machines. This must always be true for machines in linked and instant clone desktops. This defaults to true for linked and instant clone machines and false for all other types. If this is true, then machine being deleted must not have any active user session, otherwise delete operation would fail.
        /// </summary>
        /// <value>Determines whether the Machine VM should be deleted from vCenter Server. This is only applicable for managed machines. This must always be true for machines in linked and instant clone desktops. This defaults to true for linked and instant clone machines and false for all other types. If this is true, then machine being deleted must not have any active user session, otherwise delete operation would fail.</value>
        [DataMember(Name="delete_from_disk", EmitDefaultValue=false)]
        public bool? DeleteFromDisk { get; set; }

        /// <summary>
        /// Determines whether active session on the machine to be logged off before deletion. This is only applicable for managed machines. If true, active session on the machine will be logged off before Machine delete. Otherwise,it will result in an exception. 
        /// </summary>
        /// <value>Determines whether active session on the machine to be logged off before deletion. This is only applicable for managed machines. If true, active session on the machine will be logged off before Machine delete. Otherwise,it will result in an exception. </value>
        [DataMember(Name="force_logoff_session", EmitDefaultValue=false)]
        public bool? ForceLogoffSession { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MachineDeleteData {\n");
            sb.Append("  AllowDeleteFromMultiDesktopPools: ").Append(AllowDeleteFromMultiDesktopPools).Append("\n");
            sb.Append("  ArchiveDatastoreId: ").Append(ArchiveDatastoreId).Append("\n");
            sb.Append("  ArchiveDatastorePathId: ").Append(ArchiveDatastorePathId).Append("\n");
            sb.Append("  ArchivePersistentDisk: ").Append(ArchivePersistentDisk).Append("\n");
            sb.Append("  DeleteFromDisk: ").Append(DeleteFromDisk).Append("\n");
            sb.Append("  ForceLogoffSession: ").Append(ForceLogoffSession).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MachineDeleteData);
        }

        /// <summary>
        /// Returns true if MachineDeleteData instances are equal
        /// </summary>
        /// <param name="input">Instance of MachineDeleteData to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MachineDeleteData input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.AllowDeleteFromMultiDesktopPools == input.AllowDeleteFromMultiDesktopPools ||
                    (this.AllowDeleteFromMultiDesktopPools != null &&
                    this.AllowDeleteFromMultiDesktopPools.Equals(input.AllowDeleteFromMultiDesktopPools))
                ) && 
                (
                    this.ArchiveDatastoreId == input.ArchiveDatastoreId ||
                    (this.ArchiveDatastoreId != null &&
                    this.ArchiveDatastoreId.Equals(input.ArchiveDatastoreId))
                ) && 
                (
                    this.ArchiveDatastorePathId == input.ArchiveDatastorePathId ||
                    (this.ArchiveDatastorePathId != null &&
                    this.ArchiveDatastorePathId.Equals(input.ArchiveDatastorePathId))
                ) && 
                (
                    this.ArchivePersistentDisk == input.ArchivePersistentDisk ||
                    (this.ArchivePersistentDisk != null &&
                    this.ArchivePersistentDisk.Equals(input.ArchivePersistentDisk))
                ) && 
                (
                    this.DeleteFromDisk == input.DeleteFromDisk ||
                    (this.DeleteFromDisk != null &&
                    this.DeleteFromDisk.Equals(input.DeleteFromDisk))
                ) && 
                (
                    this.ForceLogoffSession == input.ForceLogoffSession ||
                    (this.ForceLogoffSession != null &&
                    this.ForceLogoffSession.Equals(input.ForceLogoffSession))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.AllowDeleteFromMultiDesktopPools != null)
                    hashCode = hashCode * 59 + this.AllowDeleteFromMultiDesktopPools.GetHashCode();
                if (this.ArchiveDatastoreId != null)
                    hashCode = hashCode * 59 + this.ArchiveDatastoreId.GetHashCode();
                if (this.ArchiveDatastorePathId != null)
                    hashCode = hashCode * 59 + this.ArchiveDatastorePathId.GetHashCode();
                if (this.ArchivePersistentDisk != null)
                    hashCode = hashCode * 59 + this.ArchivePersistentDisk.GetHashCode();
                if (this.DeleteFromDisk != null)
                    hashCode = hashCode * 59 + this.DeleteFromDisk.GetHashCode();
                if (this.ForceLogoffSession != null)
                    hashCode = hashCode * 59 + this.ForceLogoffSession.GetHashCode();
                return hashCode;
            }
        }
    }

}
